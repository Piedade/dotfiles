#!/bin/bash
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source $SCRIPT_DIR/../utils.sh

deps=(
clang
    llvm
    libxcb-errors-dev
    libre2-dev
    libglaze-dev
    libudis86-dev
    libinotify-ocaml-dev
    libmuparser-dev
)

echo_info "Installing dependencies..."
for dep in "${deps[@]}"; do
    install_package "$dep"
    if [ $? -ne 0 ]; then
        echo_error "$dep installation failed!"
        exit 1
    fi
done

name="Hyprland"
tag="v0.53.3"

echo_info "Installing $name $tag..."
if git clone --recursive -b $tag "https://github.com/hyprwm/Hyprland"; then
    cd $name || exit 1
    
    BUILD_DIR="./build/hyprland"
    mkdir -p "$BUILD_DIR"

    # Compatibility shim for toolchains without std::vector::{insert_range,append_range}
    RANGE_HDR="$(pwd)/hypr_range_compat.hpp"
    cat >"$RANGE_HDR" <<'EOF'
#pragma once
#include <iterator>
#include <ranges>
// insert at end using a range
#define INSERT_RANGE(vec, ...) (vec).insert((vec).end(), std::ranges::begin(__VA_ARGS__), std::ranges::end(__VA_ARGS__))
// insert at explicit position using a range
#define INSERT_RANGE_AT(vec, pos, ...) (vec).insert((vec).end() == (pos) ? (vec).end() : (pos), std::ranges::begin(__VA_ARGS__), std::ranges::end(__VA_ARGS__))
// append_range compatibility for containers expecting begin/end
#define APPEND_RANGE(vec, ...) (vec).insert((vec).end(), std::begin(__VA_ARGS__), std::end(__VA_ARGS__))
EOF
    # Rewrite calls:
    #   x.insert_range(pos, rng) -> INSERT_RANGE_AT(x, pos, rng)
    #   x.insert_range(rng)      -> INSERT_RANGE(x, rng)
    #   x.append_range(rng)      -> APPEND_RANGE(x, rng)
    PATCH_FILES=$(grep -REIl --exclude-dir=.git '\.\s*(insert_range|append_range)\s*\(' . || true)
    if [ -n "$PATCH_FILES" ]; then
        # Two-arg form first (pos, rng)
        perl -0777 -pi -e 's/([A-Za-z_][[:alnum:]_:.>\-]*?)\s*\.\s*insert_range\s*\(\s*([^,]+?)\s*,\s*/INSERT_RANGE_AT($1, $2, /gs' $PATCH_FILES
        # One-arg form (rng only)
        perl -0777 -pi -e 's/([A-Za-z_][[:alnum:]_:.>\-]*?)\s*\.\s*insert_range\s*\(/INSERT_RANGE($1, /gs' $PATCH_FILES
        # append_range
        perl -0777 -pi -e 's/([A-Za-z_][[:alnum:]_:.>\-]*?)\s*\.\s*append_range\s*\(/APPEND_RANGE($1, /gs' $PATCH_FILES
    fi

    # Replace #embed with an autogenerated bytes include for toolchains lacking it
    EX_CONF="$(pwd)/example/hyprland.conf"
    EMBED_INC="$(pwd)/src/config/defaultConfig.bytes.inc"
    if [ -f "$EX_CONF" ]; then
        xxd -i -g 1 -c 16 "$EX_CONF" | sed -n '/^{/{flag=1;next} /};/{flag=0} flag p' >"$EMBED_INC" || true
        # Swap the directive in the header to include the generated bytes
        sed -ri 's|^\s*#embed\s+"\.{0,2}/\.{0,2}/example/hyprland\.conf"\s*$|#include "defaultConfig.bytes.inc"|g' src/config/defaultConfig.hpp || true
    fi

    # Compatibility: some toolchains/libstdc++ do not support std::string operator+ with std::string_view.
    # Hyprland hyprctl uses a std::string_view filename; ensure it is converted explicitly.
    HYPRCTL_MAIN="$(pwd)/hyprctl/src/main.cpp"
    if [ -f "$HYPRCTL_MAIN" ] && grep -q "std::string socketPath" "$HYPRCTL_MAIN"; then
        # Only patch if we see a "+ filename" concatenation.
        if grep -qE '\+\s*filename\s*;' "$HYPRCTL_MAIN"; then
            sed -ri 's/\+\s*filename\s*;/+ std::string(filename);/g' "$HYPRCTL_MAIN" || true
        fi
    fi

    # Apply patch only if it applies cleanly; otherwise skip
    if [ -f "$PARENT_DIR/assets/0001-fix-hyprland-compile-issue.patch" ]; then
        if patch -p1 --dry-run <"$PARENT_DIR/assets/0001-fix-hyprland-compile-issue.patch" >/dev/null 2>&1; then
            patch -p1 <"$PARENT_DIR/assets/0001-fix-hyprland-compile-issue.patch"
        else
            echo_info "Hyprland compile patch does not apply on $tag; skipping."
        fi
    fi
    # By default, build Hyprland with bundled hyprutils/hyprlang to avoid version mismatches
    # You can force system libs by exporting USE_SYSTEM_HYPRLIBS=1 before running this script.
    USE_SYSTEM=${USE_SYSTEM_HYPRLIBS:-1}
  if [ "$USE_SYSTEM" = "1" ]; then
    export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:${PKG_CONFIG_PATH:-}"
    export CMAKE_PREFIX_PATH="/usr/local:${CMAKE_PREFIX_PATH:-}"
    SYSTEM_FLAGS=(
      "-DUSE_SYSTEM_HYPRUTILS=ON"
      "-DUSE_SYSTEM_HYPRLANG=ON"
      "-DUSE_SYSTEM_HYPRWIRE=ON"
    )
    # Optional preflight: verify hyprwire is discoverable by CMake/pkg-config
    if [ ! -e "/usr/local/lib/cmake/Hyprwire/HyprwireConfig.cmake" ] && ! pkg-config --exists hyprwire 2>/dev/null; then
      echo_error "hyprwire not detected in /usr/local yet. Ensure install-scripts/hyprwire.sh ran successfully or set USE_SYSTEM_HYPRLIBS=0 to use subprojects."
    fi
  else
    # Ensure we do not accidentally pick up mismatched system headers
    unset PKG_CONFIG_PATH || true
    SYSTEM_FLAGS=(
      "-DUSE_SYSTEM_HYPRUTILS=OFF"
      "-DUSE_SYSTEM_HYPRLANG=OFF"
      "-DUSE_SYSTEM_HYPRWIRE=OFF"
      "-DBUILD_HYPRCTL=OFF"
      "-DINSTALL_HYPRCTL=OFF"
    )
  fi

    # Make sure submodules are present when building bundled deps
    git submodule update --init --recursive || true

    # Force Clang toolchain to support required language features and flags
    export CC="${CC:-clang}"
    export CXX="${CXX:-clang++}"
    CONFIG_FLAGS=(
        -DCMAKE_BUILD_TYPE=Release
        -DCMAKE_C_COMPILER="${CC}"
        -DCMAKE_CXX_COMPILER="${CXX}"
        -DCMAKE_CXX_STANDARD=23
        -DCMAKE_CXX_STANDARD_REQUIRED=ON
        -DCMAKE_CXX_EXTENSIONS=ON
        -DCMAKE_CXX_FLAGS="-Wno-unknown-warning-option -include ${RANGE_HDR}"
        "${SYSTEM_FLAGS[@]}"
    )
    cmake -S . -B "$BUILD_DIR" "${CONFIG_FLAGS[@]}"
    cmake --build "$BUILD_DIR" -j "$(nproc 2>/dev/null || getconf _NPROCESSORS_CONF)"

  
        if sudo cmake --install "$BUILD_DIR"; then
            echo_success "Hyprland installed successfully."
            
            # Update version header file for tools like fastfetch that read it at runtime
            echo_info "Updating system version header for Hyprland..."
            VER_OUTPUT=""
            if [ -x "$BUILD_DIR/Hyprland" ]; then
                VER_OUTPUT=$("$BUILD_DIR/Hyprland" --version)
            elif [ -x "$BUILD_DIR/hyprland" ]; then
                VER_OUTPUT=$("$BUILD_DIR/hyprland" --version)
            elif command -v Hyprland >/dev/null 2>&1; then
                VER_OUTPUT=$(Hyprland --version)
            elif command -v hyprctl >/dev/null 2>&1; then
                VER_OUTPUT=$(hyprctl version)
            fi

            if [ -n "$VER_OUTPUT" ]; then
                VERSION=$(printf '%s' "$VER_OUTPUT" | head -n1 | awk '{print $2}')
                COMMIT=$(printf '%s' "$VER_OUTPUT" | grep -oP 'commit \K[a-f0-9]+' | head -1)
                TAG=$(printf '%s' "$VER_OUTPUT" | grep -oP 'Tag: \K[^,]+' | head -1)
                COMMIT_DATE=$(printf '%s' "$VER_OUTPUT" | grep -oP '^Date:\s+\K.*' | head -1)
                COMMITS=$(printf '%s' "$VER_OUTPUT" | grep -oP 'commits:\s*\K[0-9]+' | head -1)
                DIRTY=$(printf '%s' "$VER_OUTPUT" | grep -qi 'dirty' && echo "dirty" || echo "clean")
                COMMIT_MSG=$(printf '%s' "$VER_OUTPUT" | head -n1 | sed -n 's/.*(version: \(.*\))\..*/\1/p')

                [ -z "$COMMIT" ] && COMMIT="unknown"
                [ -z "$TAG" ] && TAG="v$VERSION"
                [ -z "$COMMIT_DATE" ] && COMMIT_DATE="$(date)"
                [ -z "$COMMITS" ] && COMMITS="0"
                [ -z "$COMMIT_MSG" ] && COMMIT_MSG="version: bump"

                # Prefer versions from hyprland --version; fall back to hypr-tags.env values
                parse_ver() { printf '%s' "$VER_OUTPUT" | grep -m1 "$1:" | grep -oP '\d+\.\d+\.\d+' | head -1; }
                AQUA_VER=$(parse_ver "Aquamarine")
                HYPRLANG_VER=$(parse_ver "Hyprlang")
                HYPRUTILS_VER=$(parse_ver "Hyprutils")
                HYPRCURSOR_VER=$(parse_ver "Hyprcursor")
                HYPRGRAPHICS_VER=$(parse_ver "Hyprgraphics")

                [ -z "$AQUA_VER" ] && AQUA_VER="${AQUAMARINE_TAG#v}"
                [ -z "$HYPRLANG_VER" ] && HYPRLANG_VER="${HYPRLANG_TAG#v}"
                [ -z "$HYPRUTILS_VER" ] && HYPRUTILS_VER="${HYPRUTILS_TAG#v}"
                [ -z "$HYPRGRAPHICS_VER" ] && HYPRGRAPHICS_VER="${HYPRGRAPHICS_TAG#v}"
                [ -z "$HYPRCURSOR_VER" ] && HYPRCURSOR_VER="0.1.13"
                [ -z "$AQUA_VER" ] && AQUA_VER="0.0.0"
                [ -z "$HYPRLANG_VER" ] && HYPRLANG_VER="0.0.0"
                [ -z "$HYPRUTILS_VER" ] && HYPRUTILS_VER="0.0.0"
                [ -z "$HYPRGRAPHICS_VER" ] && HYPRGRAPHICS_VER="0.0.0"

                # AQUAMARINE_VERSION components
                AQUA_MAJOR=$(echo "$AQUA_VER" | cut -d. -f1)
                AQUA_MINOR=$(echo "$AQUA_VER" | cut -d. -f2)
                AQUA_PATCH=$(echo "$AQUA_VER" | cut -d. -f3)

                # Use printf to safely write the file
                printf '%s\n' "#pragma once" > /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMIT_HASH    \"$COMMIT\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_BRANCH         \"\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMIT_MESSAGE \"$COMMIT_MSG\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMIT_DATE    \"$COMMIT_DATE\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_DIRTY          \"$DIRTY\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_TAG            \"$TAG\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMITS        \"$COMMITS\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION \"$AQUA_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "// clang-format off" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION_MAJOR $AQUA_MAJOR" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION_MINOR $AQUA_MINOR" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION_PATCH $AQUA_PATCH" >> /tmp/version_header.h.tmp
                printf '%s\n' "// clang-format on" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRLANG_VERSION     \"$HYPRLANG_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRUTILS_VERSION    \"$HYPRUTILS_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRCURSOR_VERSION   \"$HYPRCURSOR_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRGRAPHICS_VERSION \"$HYPRGRAPHICS_VER\"" >> /tmp/version_header.h.tmp

                TARGETS=()
                if [ -f /usr/local/include/hyprland/src/version.h ]; then
                    TARGETS+=(/usr/local/include/hyprland/src/version.h)
                fi
                if [ -f /usr/include/hyprland/src/version.h ]; then
                    # If both exist, keep /usr/include in sync to avoid fastfetch mismatch.
                    TARGETS+=(/usr/include/hyprland/src/version.h)
                fi
                if [ ${#TARGETS[@]} -eq 0 ]; then
                    # Default to /usr/local if neither header exists yet.
                    TARGETS+=(/usr/local/include/hyprland/src/version.h)
                fi

                UPDATED=0
                for tgt in "${TARGETS[@]}"; do
                    if sudo install -d "$(dirname "$tgt")" && sudo cp /tmp/version_header.h.tmp "$tgt"; then
                        UPDATED=1
                    fi
                done

                if [ $UPDATED -eq 1 ]; then
                    echo_success "System version header updated to $VERSION"
                else
                    echo_info "Could not update system version header (non-critical)"
                fi
                rm -f /tmp/version_header.h.tmp
            else
                echo_info "Could not determine Hyprland version output for header update (non-critical)"
            fi
        else
            echo_error "Installation failed for $name"
        fi


    cd ..
else
    echo_error "Download failed for $name!"
fi

rm -rf ./$name
